#!/usr/bin/python3

# Python code for X-point radiator access parameter analysis made by:
# - Luca Cinnirella
#
# and modified/updated by:
#

# Last update: 08.03.2022

# IMPORTS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import sys
import argparse
import pandas as pd
import numpy as np
import aug_sfutils as sf
import scipy.ndimage as ndm
import scipy.io
import matplotlib.pyplot as plt
from matplotlib import style

import sig_proc as sgpr
import manual_calibrators as manc


# OPTIONS HANDLER
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser = argparse.ArgumentParser(description='Plot time traces of edge ' +
                                 'temperature profile')
parser.add_argument('shot', metavar='SHOT_NUMBER', type=int,
                    help='Execute the code for shot #SHOT_NUMBER')
parser.add_argument('-w', '--time_window', metavar='TIME_WINDOW', type=float,
                    default=50.,
                    help='Set the time window (in ms) length on which to ' +
                    'apply median filter.\nThe step size of the median ' +
                    'filter is also set to 1/3 of the given window length. ' +
                    'In this way  a decimation is also applied together ' +
                    'with the filter (default is 50)')
parser.add_argument('-m', '--mag_equ_diag', type=str, default='EQH',
                    choices=['FPP', 'EQI', 'EQH'],
                    help='Select which diagnostic is used for magnetic ' +
                    'reconstruction (FPP, EQI or EQH, default is EQH)')
parser.add_argument('-p', '--plot_quantities', type=str, nargs='*',
                    choices=['q_s', 'f_exp', 'n_0', 'n_u', 'T_u', '2pm',
                             'z_XPR'],
                    help='Some nice things to say')
args = parser.parse_args()

if args.mag_equ_diag == 'FPP':
    FPG_DIAG = 'FPG'
elif args.mag_equ_diag == 'EQI':
    FPG_DIAG = 'GQI'
elif args.mag_equ_diag == 'EQH':
    FPG_DIAG = 'GQH'

shot = args.shot
time_window = args.time_window / 1000
mag_equ_diag = args.mag_equ_diag
plot_quantities = args.plot_quantities
if plot_quantities is not None:
    if len(plot_quantities) > len(set(plot_quantities)):
        raise ValueError('You may choose every quantity once!')


# READING RADIATIVE AND COLD CORE XPR STARTING TIMES
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# In this section the XPR_rad_times.csv and XPR_cld_times.csv are read in order
# to gather data about the starting times and relative uncertainties of
# radiative and cold core XPR. The data are presented as array containg the
# best guesses (rad_start or cld_start), the lower boundaries of the various
# time intervals due to uncertainties (rad_low_t and cld_low_t) and the upper
# boundaries too (rad_up_t and cld_up_t).
# rad_no_t and cld_no_t are introduced in order to simplify the subsequent
# plotting process: since matplotlib.pyplot.fill_between can be selectively
# activated on each point based on a Boolean array. The main idea is to build
# a 1D array that looks like this:
#
# [first lower boundary, first upper boundary, first time in between, ...,
#  nth lower boundary, nth upper boundary, nth time in between]
#
# which should be accompanied by such a boolean array:
#
# [True, True, False, ..., True, True, False]
#
# Since time is always positive, rad_no_t can be generated by filling it only
# with -1. After that, np.r_ combines the lower boundaries array, the upper
# boundaries array and the template for the in between times array into a
# matrix that looks like this:
#
# rad_intervals = [rad_low_t,
#                  rad_up_t,
#                  rad_no_t  ]
#
# By querying rad_intervals != -1 we get a Boolean matrix with same shape as
# rad_intervals, completely filled with True values except for the last row
# (representing the time points that should be deactivated by
# matplotlib.pyplot.fill_between).
# Finally, we can sbustitute the -1 in the last row with values that are in
# between the upper boundary of a time interval and lower boundary of the next
# one (mean between second row same column and first row next column).
# The transposed and flattened versions of the two matrices are indeed, the
# array that we were looking for!

df_rad_time = pd.read_csv('./csvs/XPR_rad_times.csv', index_col=0).loc[shot]

rad_start = np.atleast_1d(df_rad_time['start'])

rad_low_t = np.atleast_1d(df_rad_time['start']
                          - df_rad_time['err. start'])
rad_up_t = np.atleast_1d(df_rad_time['start']
                         + df_rad_time['err. start'])
rad_no_t = np.zeros_like(rad_start) - 1
rad_intervals = np.r_['0,2', rad_low_t, rad_up_t, rad_no_t]

rad_highlight = (rad_intervals != -1).T.flatten()

rad_intervals[2, :-1] = (rad_intervals[0, 1:] + rad_intervals[1, :-1]) / 2
rad_intervals[2, -1] = rad_intervals[1, -1] + 0.01
rad_intervals = rad_intervals.T.flatten()


df_cld_time = pd.read_csv('./csvs/XPR_cld_times.csv', index_col=0).loc[shot]

cld_start = np.atleast_1d(df_cld_time['start'])

cld_low_t = np.atleast_1d(df_cld_time['start']
                          - df_cld_time['err. start'])
cld_up_t = np.atleast_1d(df_cld_time['start']
                         + df_cld_time['err. start'])
cld_no_t = np.zeros_like(cld_start) - 1
cld_intervals = np.r_['0,2', cld_low_t, cld_up_t, cld_no_t]

cld_highlight = (cld_intervals != -1).T.flatten()

cld_intervals[2, :-1] = (cld_intervals[0, 1:] + cld_intervals[1, :-1]) / 2
cld_intervals[2, -1] = cld_intervals[1, -1] + 0.01
cld_intervals = cld_intervals.T.flatten()


# READING SHOT TIME BOUNDARIES
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df_shot_time = pd.read_csv('./csvs/equilibria.csv', index_col=0).loc[shot]

shot_start = df_shot_time['start']
shot_end = df_shot_time['end']


# READING XPR POSITION DATA
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
df_pos_xpr = pd.read_csv('./csvs/XPR_position/' + str(shot) +
                         '_XPR_position_gaussian.csv', index_col=0)
time_xpr = df_pos_xpr.index.values
R_xpr = df_pos_xpr['R (m)'].values
z_xpr = df_pos_xpr['z (m)'].values
good_pos_xpr = df_pos_xpr['detection with scipy.signal.find_peaks ' +
                          '(bool)'].values


# QUERYING SHOTS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get shot-files relative to function parametrization, equilibrium , integrated
# data analysis, ionization manometers, total injected power and power radiated
# inside the separatrix
fpg = sf.SFREAD(shot, FPG_DIAG)
equ = sf.EQU(shot, diag=mag_equ_diag)
ida = sf.SFREAD(shot, 'IDA')
ioa = manc.SFIOCF01(shot, sensitivity=3.)
iob = manc.SFIOCF01(shot)
ioc = manc.SFIOCF01(shot, sensitivity=2.)
tot = sf.SFREAD(shot, 'TOT')
bpt = sf.SFREAD(shot, 'BPT', exp='DAVIDP')


# QUERYING SIGNALS
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get calibrated time traces for position of the magnetic axis, minor
# horizontal plasma radius, q95, position of the lower x-point, upstream
# temperature and density, F01 divertor manometer, total injected power,
# irradiated power within the separatrix (X-point excluded) and upstream
# temperature and density from two point model reconstruction (by Thomas Eich)
if fpg.status:
    r_magax = fpg.getobject('Rmag', cal=True).astype(np.double)
    z_magax = fpg.getobject('Zmag', cal=True).astype(np.double)
    a = fpg.getobject('ahor', cal=True).astype(np.double)
    q_95 = -fpg.getobject('q95', cal=True).astype(np.double)
    r_xp = fpg.getobject('Rxpu', cal=True).astype(np.double)
    z_xp = fpg.getobject('Zxpu', cal=True).astype(np.double)
    time_fpg = fpg.gettimebase('Zmag')
else:
    sys.exit('Error while loading ' + FPG_DIAG)

if ida.status:
    T_u = ida.getobject('Te', cal=True).astype(np.double)
    n_u = ida.getobject('ne', cal=True).astype(np.double)
    area_ida = ida.getareabase('Te')
    time_ida = ida.gettimebase('Te')
    # Choosing separatrix data
    ida_idx = sgpr.find_nearest_index(area_ida, 1.0, axis=0)
    T_u = T_u[ida_idx, np.arange(time_ida.size)]
    n_u = n_u[ida_idx, np.arange(time_ida.size)]
else:
    sys.exit('Error while loading IDA')

if ioa.status and iob.status and ioc.status:
    n_0_l = ioa.getobject('F01').astype(np.double)
    n_0 = iob.getobject('F01').astype(np.double)
    n_0_u = ioc.getobject('F01').astype(np.double)
    time_iob = iob.gettimebase()
    iob_par = iob.getparset('CONVERT')
    iob_2_n = iob_par['density']
    n_0_l = n_0_l * iob_2_n
    n_0 = n_0 * iob_2_n
    n_0_u = n_0_u * iob_2_n
else:
    sys.exit('Error while loading IOB')

if tot.status:
    P_tot = tot.getobject('P_TOT', cal=True).astype(np.double)
    time_tot = tot.gettimebase('P_TOT')
else:
    sys.exit('Error while loading TOT')

if bpt.status:
    P_rad = bpt.getobject('Pr_sepX', cal=True).astype(np.double)
    time_bpt = bpt.gettimebase('Pr_sepX')
else:
    sys.exit('Error while loading BPT')

mat = scipy.io.loadmat('./T_Eich_data/sep_asdex_high_' + str(shot) +
                       '.mat')['sosdata']
n_2pm = mat[0]
T_2pm = mat[1]
time_2pm = mat[4]

print('\n\n')
print('Querying: done')


# UNIVERSAL TIME SELECTION
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get maximum common time interval boundaries
start = max(time_fpg[0], time_ida[0], time_iob[0], time_tot[0], time_bpt[0],
            time_xpr[0], shot_start)
end = min(time_fpg[-1], time_ida[-1], time_iob[-1], time_tot[-1], time_bpt[-1],
          time_xpr[-1], shot_end)

# Get indexes of boundaries for XPR
start_index_xpr = sgpr.find_nearest_index(time_xpr, start)
end_index_xpr = sgpr.find_nearest_index(time_xpr, end)

# Get indexes of boundaries for FPG
start_index_fpg = sgpr.find_nearest_index(time_fpg, start)
end_index_fpg = sgpr.find_nearest_index(time_fpg, end)

# Get indexes of boundaries for IDA
start_index_ida = sgpr.find_nearest_index(time_ida, start)
end_index_ida = sgpr.find_nearest_index(time_ida, end)

# Get indexes of boundaries for IOB
start_index_iob = sgpr.find_nearest_index(time_iob, start)
end_index_iob = sgpr.find_nearest_index(time_iob, end)

# Get indexes of boundaries for TOT
start_index_tot = sgpr.find_nearest_index(time_tot, start)
end_index_tot = sgpr.find_nearest_index(time_tot, end)

# Get indexes of boundaries for BPT
start_index_bpt = sgpr.find_nearest_index(time_bpt, start)
end_index_bpt = sgpr.find_nearest_index(time_bpt, end)

# Slice XPR quantities and relative time
R_xpr = R_xpr[..., start_index_xpr:end_index_xpr + 1]
z_xpr = z_xpr[..., start_index_xpr:end_index_xpr + 1]
good_pos_xpr = good_pos_xpr[..., start_index_xpr:end_index_xpr + 1]
time_xpr = time_xpr[..., start_index_xpr:end_index_xpr + 1]

# Slice FPG quantities and relative time
r_magax = r_magax[..., start_index_fpg:end_index_fpg + 1]
z_magax = z_magax[..., start_index_fpg:end_index_fpg + 1]
a = a[..., start_index_fpg:end_index_fpg + 1]
q_95 = q_95[..., start_index_fpg:end_index_fpg + 1]
r_xp = r_xp[..., start_index_fpg:end_index_fpg + 1]
z_xp = z_xp[..., start_index_fpg:end_index_fpg + 1]
time_fpg = time_fpg[..., start_index_fpg:end_index_fpg + 1]

# Slice IDA quantities and relative time
T_u = T_u[..., start_index_ida:end_index_ida + 1]
n_u = n_u[..., start_index_ida:end_index_ida + 1]
time_ida = time_ida[..., start_index_ida:end_index_ida + 1]

# Slice IOB quantities and relative time
n_0_l = n_0_l[..., start_index_iob:end_index_iob + 1]
n_0 = n_0[..., start_index_iob:end_index_iob + 1]
n_0_u = n_0_u[..., start_index_iob:end_index_iob + 1]
time_iob = time_iob[..., start_index_iob:end_index_iob + 1]

# Slice TOT quantities and relative time
P_tot = P_tot[..., start_index_tot:end_index_tot + 1]
time_tot = time_tot[..., start_index_tot:end_index_tot + 1]

# Slice BPT quantities and relative time
P_rad = P_rad[..., start_index_bpt:end_index_bpt + 1]
time_bpt = time_bpt[..., start_index_bpt:end_index_bpt + 1]

print('Time selection done')


# MEDIAN FILTERING
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Evaluate sampling rate for median filter function (sampling rates in the
# middle of a time trace are more reliable than averages)
f_s_fpg = 1 / (time_fpg[int(time_fpg.size / 2) + 1] -
               time_fpg[int(time_fpg.size / 2)])
f_s_ida = 1 / (time_ida[int(time_ida.size / 2) + 1] -
               time_ida[int(time_ida.size / 2)])
f_s_iob = 1 / (time_iob[int(time_iob.size / 2) + 1] -
               time_iob[int(time_iob.size / 2)])
f_s_tot = 1 / (time_tot[int(time_tot.size / 2) + 1] -
               time_tot[int(time_tot.size / 2)])
f_s_bpt = 1 / (time_bpt[int(time_bpt.size / 2) + 1] -
               time_bpt[int(time_bpt.size / 2)])
f_s_2pm = 1 / (time_2pm[int(time_2pm.size / 2) + 1] -
               time_2pm[int(time_2pm.size / 2)])

# Apply median filters on IDA quantities
_, T_u = sgpr.median_filter(f_s_ida, time_window, time_ida, T_u)
time_ida, n_u = sgpr.median_filter(f_s_ida, time_window, time_ida, n_u)

# Apply median filters on IOB quantities
_, n_0_l = sgpr.median_filter(f_s_iob, time_window, time_iob, n_0_l)
_, n_0 = sgpr.median_filter(f_s_iob, time_window, time_iob, n_0)
time_iob, n_0_u = sgpr.median_filter(f_s_iob, time_window, time_iob, n_0_u)

# Apply median filters on TOT quantities
time_tot, P_tot = sgpr.median_filter(f_s_tot, time_window, time_tot, P_tot)

# Apply median filters on BPT quantities
time_bpt, P_rad = sgpr.median_filter(f_s_bpt, time_window, time_bpt, P_rad)

# Re-evaluate sampling rate for filtered quantities
f_s_ida = 1 / (time_ida[int(time_ida.size / 2) + 1] -
               time_ida[int(time_ida.size / 2)])
f_s_iob = 1 / (time_iob[int(time_iob.size / 2) + 1] -
               time_iob[int(time_iob.size / 2)])
f_s_tot = 1 / (time_tot[int(time_tot.size / 2) + 1] -
               time_tot[int(time_tot.size / 2)])
f_s_bpt = 1 / (time_bpt[int(time_bpt.size / 2) + 1] -
               time_bpt[int(time_bpt.size / 2)])

print('Median filters applied')


# FLUX EXPANSION RATIO
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get coordinates of the intersection between the ρ95 surface and the line
# connecting the magnetic axis with the lower x-point. Then, evaluate the
# distance between the intersection and the lower x-point itself
magax = np.array([r_magax, z_magax])
xp = np.array([r_xp, z_xp])
theta = np.arctan2(xp[1]-magax[1], xp[0]-magax[0])
r_l95_int = list()
z_l95_int = list()

for index, time in enumerate(time_fpg):
    r_l95_temp, z_l95_temp = sf.rhoTheta2rz(equ, 0.95, theta_in=theta[index],
                                            t_in=time,
                                            coord_in='rho_pol')
    r_l95_int.append(r_l95_temp.flatten()[0])
    z_l95_int.append(z_l95_temp.flatten()[0])

l95_intersection = np.array([r_l95_int, z_l95_int])
xp_expansion = np.linalg.norm(l95_intersection - xp, axis=0).astype(np.double)

# Get coordinates of the intersection between the mid-plane and the ρ100 and
# ρ95 surfaces. Then, evaluate the distance between the two
r_m100_int, z_m100_int = sf.rhoTheta2rz(equ, 1, theta_in=0, t_in=time_fpg,
                                        coord_in='rho_pol')
m100_intersection = np.array([r_m100_int.flatten(), z_m100_int.flatten()])
r_m95_int, z_m95_int = sf.rhoTheta2rz(equ, 0.95, theta_in=0,
                                      t_in=time_fpg,
                                      coord_in='rho_pol')
m95_intersection = np.array([r_m95_int.flatten(), z_m95_int.flatten()])
mid_expansion = np.linalg.norm(m100_intersection - m95_intersection,
                               axis=0).astype(np.double)

# The flux expansion ratio should be the ratio between two areas enveloping the
# same magnetic lines but, due to the thoroidal symmetry, it can be reduced to
# the ratio of distances between the magnetic surfaces
f_exp = xp_expansion / mid_expansion
# We must remove spikes due to bad magnetic reconstruction (usually flux
# expansion is expected to be between 0 and 20)
correction_indexes = (~np.asarray((f_exp < 20) &
                                  (f_exp > 0))).nonzero()[0]
f_exp[correction_indexes] = (f_exp[correction_indexes + 1] +
                             f_exp[correction_indexes - 1]) / 2

print('Flux expansion evaluated')


# SPECIFIC TIME POINTS SELECTION AND FILTERING FOR X_A WITH T_u
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Query for shortest time array. It will be used to evaluate sampling rate for
# gaussian filters sigma computation and for resampling
time_wT = sgpr.shortest_array([time_fpg, time_ida, time_iob])
f_s_wT = 1 / (time_wT[int(time_wT.size / 2) + 1] -
              time_wT[int(time_wT.size / 2)])

# Apply gaussian filter to FPG quantities
R_0_wT = ndm.gaussian_filter(r_magax, f_s_fpg / (2 * f_s_wT))
a_wT = ndm.gaussian_filter(a, f_s_fpg / (2 * f_s_wT))
q_95_wT = ndm.gaussian_filter(q_95, f_s_fpg / (2 * f_s_wT))
f_exp_wT = ndm.gaussian_filter(f_exp, f_s_fpg / (2 * f_s_wT))

# Apply gaussian filter to IDA quantities
T_u_wT = ndm.gaussian_filter(T_u, f_s_ida / (2 * f_s_wT))
n_u_wT = ndm.gaussian_filter(n_u, f_s_ida / (2 * f_s_wT))

# Apply gaussian filter to IOB quantities
n_0_lwT = ndm.gaussian_filter(n_0_l, f_s_iob / (2 * f_s_wT))
n_0_wT = ndm.gaussian_filter(n_0, f_s_iob / (2 * f_s_wT))
n_0_uwT = ndm.gaussian_filter(n_0_u, f_s_iob / (2 * f_s_wT))

# Re-slice FPG quantities
fpg_indexes_wT, _ = sgpr.find_nearest_multiple_index(time_fpg, time_wT)
R_0_wT = R_0_wT[fpg_indexes_wT]
a_wT = a_wT[fpg_indexes_wT]
q_95_wT = q_95_wT[fpg_indexes_wT]
f_exp_wT = f_exp_wT[fpg_indexes_wT]
time_fpg_wT = time_fpg[fpg_indexes_wT]

# Re-slice IDA quantities
ida_indexes_wT, _ = sgpr.find_nearest_multiple_index(time_ida, time_wT)
T_u_wT = T_u_wT[ida_indexes_wT]
n_u_wT = n_u_wT[ida_indexes_wT]
time_ida_wT = time_ida[ida_indexes_wT]

# Re-slice IOB quantities
iob_indexes_wT, _ = sgpr.find_nearest_multiple_index(time_iob, time_wT)
n_0_lwT = n_0_lwT[iob_indexes_wT]
n_0_wT = n_0_wT[iob_indexes_wT]
n_0_uwT = n_0_uwT[iob_indexes_wT]
time_iob_wT = time_iob[iob_indexes_wT]

print('Downsampling executed')


# EVALUATION OF X_A WITH T_u
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X_A_lwT = R_0_wT**2 * q_95_wT**2 * f_exp_wT * n_u_wT * \
            n_0_lwT / (a_wT * T_u_wT**(5/2))
X_A_wT = R_0_wT**2 * q_95_wT**2 * f_exp_wT * n_u_wT * \
            n_0_wT / (a_wT * T_u_wT**(5/2))
X_A_uwT = R_0_wT**2 * q_95_wT**2 * f_exp_wT * n_u_wT * \
            n_0_uwT / (a_wT * T_u_wT**(5/2))

print('X_A evaluated with T_u')


# SPECIFIC TIME POINTS SELECTION AND FILTERING FOR X_A WITH P_sep
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Query for shortest time array. It will be used to evaluate sampling rate for
# gaussian filters sigma computation and for resampling
time_wP = sgpr.shortest_array([time_fpg, time_ida, time_iob, time_tot,
                               time_bpt])
f_s_wP = 1 / (time_wP[int(time_wP.size / 2) + 1] -
              time_wP[int(time_wP.size / 2)])

# Apply gaussian filter to FPG quantities
R_0_wP = ndm.gaussian_filter(r_magax, f_s_fpg / (2 * f_s_wP))
q_95_wP = ndm.gaussian_filter(q_95, f_s_fpg / (2 * f_s_wP))
f_exp_wP = ndm.gaussian_filter(f_exp, f_s_fpg / (2 * f_s_wP))

# Apply gaussian filter to IDA quantities
n_u_wP = ndm.gaussian_filter(n_u, f_s_ida / (2 * f_s_wP))

# Apply gaussian filter to IOB quantities
n_0_lwP = ndm.gaussian_filter(n_0_l, f_s_iob / (2 * f_s_wP))
n_0_wP = ndm.gaussian_filter(n_0, f_s_iob / (2 * f_s_wP))
n_0_uwP = ndm.gaussian_filter(n_0_u, f_s_iob / (2 * f_s_wP))

# Apply gaussian filter to TOT quantities
P_tot_wP = ndm.gaussian_filter(P_tot, f_s_tot / (2 * f_s_wP))

# Apply gaussian filter to BPT quantities
P_rad_wP = ndm.gaussian_filter(P_rad, f_s_bpt / (2 * f_s_wP))

# Re-slice FPG quantities
fpg_indexes_wP, _ = sgpr.find_nearest_multiple_index(time_fpg, time_wP)
R_0_wP = R_0_wP[fpg_indexes_wP]
q_95_wP = q_95_wP[fpg_indexes_wP]
f_exp_wP = f_exp_wP[fpg_indexes_wP]
time_fpg_wP = time_fpg[fpg_indexes_wP]

# Re-slice IDA quantities
ida_indexes_wP, _ = sgpr.find_nearest_multiple_index(time_ida, time_wP)
n_u_wP = n_u_wP[ida_indexes_wP]
time_ida_wP = time_ida[ida_indexes_wP]

# Re-slice IOB quantities
iob_indexes_wP, _ = sgpr.find_nearest_multiple_index(time_iob, time_wP)
n_0_lwP = n_0_lwP[iob_indexes_wP]
n_0_wP = n_0_wP[iob_indexes_wP]
n_0_uwP = n_0_uwP[iob_indexes_wP]
time_iob_wP = time_iob[iob_indexes_wP]

# Re-slice TOT quantities
tot_indexes_wP, _ = sgpr.find_nearest_multiple_index(time_tot, time_wP)
P_tot_wP = P_tot_wP[tot_indexes_wP]
time_tot_wP = time_tot[tot_indexes_wP]

# Re-slice BPT quantities
bpt_indexes_wP, _ = sgpr.find_nearest_multiple_index(time_bpt, time_wP)
P_rad_wP = P_rad_wP[bpt_indexes_wP]
time_bpt_wP = time_bpt[bpt_indexes_wP]

print('Downsampling executed')


# EVALUATION OF X_A WITH P_sep
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X_A_lwP = R_0_wP**2 * q_95_wP**(8/9) * f_exp_wP * n_0_lwP * n_u_wP**(14/9) \
        / ((P_tot_wP - P_rad_wP)**(10/9))
X_A_wP = R_0_wP**2 * q_95_wP**(8/9) * f_exp_wP * n_0_wP * n_u_wP**(14/9) \
        / ((P_tot_wP - P_rad_wP)**(10/9))
X_A_uwP = R_0_wP**2 * q_95_wP**(8/9) * f_exp_wP * n_0_uwP * n_u_wP**(14/9) \
        / ((P_tot_wP - P_rad_wP)**(10/9))

print('X_A evaluated with P_sep')


# TIME SELECTION FOR X_A EVALUATED WITH T_2pm
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
start_2pm = max(time_fpg[0], time_ida[0], time_iob[0], time_xpr[0], shot_start)
end_2pm = min(time_fpg[-1], time_ida[-1], time_iob[-1], time_xpr[-1], shot_end)

# Get indexes of boundaries for XPR
start_index_xpr_2pm = sgpr.find_nearest_index(time_xpr, start_2pm)
end_index_xpr_2pm = sgpr.find_nearest_index(time_xpr, end_2pm)

# Get indexes of boundaries for FPG
start_index_fpg_2pm = sgpr.find_nearest_index(time_fpg, start_2pm)
end_index_fpg_2pm = sgpr.find_nearest_index(time_fpg, end_2pm)

# Get indexes of boundaries for 2PM
start_index_2pm_2pm = sgpr.find_nearest_index(time_2pm, start_2pm)
end_index_2pm_2pm = sgpr.find_nearest_index(time_2pm, end_2pm)

# Get indexes of boundaries for IOB
start_index_iob_2pm = sgpr.find_nearest_index(time_iob, start_2pm)
end_index_iob_2pm = sgpr.find_nearest_index(time_iob, end_2pm)

# Slice XPR quantities and relative time
R_xpr_2pm = R_xpr[..., start_index_xpr_2pm:end_index_xpr_2pm + 1]
z_xpr_2pm = z_xpr[..., start_index_xpr_2pm:end_index_xpr_2pm + 1]
good_pos_xpr_2pm = good_pos_xpr[..., start_index_xpr_2pm:end_index_xpr_2pm + 1]
time_xpr_2pm = time_xpr[..., start_index_xpr_2pm:end_index_xpr_2pm + 1]

# Slice FPG quantities and relative time
r_magax_2pm = r_magax[..., start_index_fpg_2pm:end_index_fpg_2pm + 1]
a_2pm = a[..., start_index_fpg_2pm:end_index_fpg_2pm + 1]
q_95_2pm = q_95[..., start_index_fpg_2pm:end_index_fpg_2pm + 1]
f_exp_2pm = f_exp[..., start_index_fpg_2pm:end_index_fpg_2pm + 1]
time_fpg_2pm = time_fpg[..., start_index_fpg_2pm:end_index_fpg_2pm + 1]

# Slice 2PM quantities and relative time
T_2pm = T_2pm[..., start_index_2pm_2pm:end_index_2pm_2pm + 1]
n_2pm = n_2pm[..., start_index_2pm_2pm:end_index_2pm_2pm + 1]
time_2pm = time_2pm[..., start_index_2pm_2pm:end_index_2pm_2pm + 1]

# Slice IOB quantities and relative time
n_0_l2pm = n_0_l[..., start_index_iob_2pm:end_index_iob_2pm + 1]
n_0_2pm = n_0[..., start_index_iob_2pm:end_index_iob_2pm + 1]
n_0_u2pm = n_0_u[..., start_index_iob_2pm:end_index_iob_2pm + 1]
time_iob_2pm = time_iob[..., start_index_iob_2pm:end_index_iob_2pm + 1]


# SPECIFIC TIME POINTS SELECTION AND FILTERING FOR X_A WITH T_u
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Query for shortest time array. It will be used to evaluate sampling rate for
# gaussian filters sigma computation and for resampling
time_w2pm = sgpr.shortest_array([time_fpg_2pm, time_2pm, time_iob_2pm])
f_s_w2pm = 1 / (time_w2pm[int(time_w2pm.size / 2) + 1] -
                time_w2pm[int(time_w2pm.size / 2)])

# Apply gaussian filter to FPG quantities
R_0_w2pm = ndm.gaussian_filter(r_magax_2pm, f_s_fpg / (2 * f_s_w2pm))
a_w2pm = ndm.gaussian_filter(a_2pm, f_s_fpg / (2 * f_s_w2pm))
q_95_w2pm = ndm.gaussian_filter(q_95_2pm, f_s_fpg / (2 * f_s_w2pm))
f_exp_w2pm = ndm.gaussian_filter(f_exp_2pm, f_s_fpg / (2 * f_s_w2pm))

# Apply gaussian filter to 2PM quantities
T_u_w2pm = ndm.gaussian_filter(T_2pm, f_s_2pm / (2 * f_s_w2pm))
n_u_w2pm = ndm.gaussian_filter(n_2pm, f_s_2pm / (2 * f_s_w2pm))

# Apply gaussian filter to IOB quantities
n_0_lw2pm = ndm.gaussian_filter(n_0_l2pm, f_s_iob / (2 * f_s_w2pm))
n_0_w2pm = ndm.gaussian_filter(n_0_2pm, f_s_iob / (2 * f_s_w2pm))
n_0_uw2pm = ndm.gaussian_filter(n_0_u2pm, f_s_iob / (2 * f_s_w2pm))

# Re-slice FPG quantities
fpg_indexes_w2pm, _ = sgpr.find_nearest_multiple_index(time_fpg_2pm, time_w2pm)
R_0_w2pm = R_0_w2pm[fpg_indexes_w2pm]
a_w2pm = a_w2pm[fpg_indexes_w2pm]
q_95_w2pm = q_95_w2pm[fpg_indexes_w2pm]
f_exp_w2pm = f_exp_w2pm[fpg_indexes_w2pm]
time_fpg_w2pm = time_fpg[fpg_indexes_w2pm]

# Re-slice upstream quantities
upp_indexes_w2pm, _ = sgpr.find_nearest_multiple_index(time_2pm, time_w2pm)
T_u_w2pm = T_u_w2pm[upp_indexes_w2pm]
n_u_w2pm = n_u_w2pm[upp_indexes_w2pm]
time_2pm_w2pm = time_2pm[upp_indexes_w2pm]

# Re-slice IOB quantities
iob_indexes_w2pm, _ = sgpr.find_nearest_multiple_index(time_iob_2pm, time_w2pm)
n_0_lw2pm = n_0_lw2pm[iob_indexes_w2pm]
n_0_w2pm = n_0_w2pm[iob_indexes_w2pm]
n_0_uw2pm = n_0_uw2pm[iob_indexes_w2pm]
time_iob_w2pm = time_iob_2pm[iob_indexes_w2pm]

print('Downsampling executed')


# EVALUATION OF X_A WITH T_u FROM TWO POINT MODEL
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X_A_lw2pm = R_0_w2pm**2 * q_95_w2pm**2 * f_exp_w2pm * n_u_w2pm * \
            n_0_lw2pm / (a_w2pm * T_u_w2pm**(5/2))
X_A_w2pm = R_0_w2pm**2 * q_95_w2pm**2 * f_exp_w2pm * n_u_w2pm * \
            n_0_w2pm / (a_w2pm * T_u_w2pm**(5/2))
X_A_uw2pm = R_0_w2pm**2 * q_95_w2pm**2 * f_exp_w2pm * n_u_w2pm * \
            n_0_uw2pm / (a_w2pm * T_u_w2pm**(5/2))

print('X_A evaluated with T_u from two point model reconstruction')


# PLOTTING
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# General settings
style.use('bmh')
plt.rc('font', size=16)
colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
px = 1/plt.rcParams['figure.dpi']  # from pixel to inches
fig = plt.figure(figsize=(960*px, 1080*px))
plt.suptitle(f'SHOT #{shot}', fontsize=32, fontweight='bold')

# Subplots
if plot_quantities:
    rows = len(plot_quantities) + 1
    ax1 = plt.subplot2grid((rows, 2), (0, 0), rowspan=1, colspan=1)
    ay1 = plt.subplot2grid((rows, 2), (0, 1), rowspan=1, colspan=1)
    ax = list()
    ay = list()

    for index, quantity in enumerate(plot_quantities):
        ax.append(plt.subplot2grid((rows, 2), (index + 1, 0), rowspan=1,
                                   colspan=1))
        ay.append(plt.subplot2grid((rows, 2), (index + 1, 1), rowspan=1,
                                   colspan=1))

        ax[-1].fill_between(rad_intervals, 0, 1, where=rad_highlight,
                            color='coral', alpha=0.5,
                            transform=ax[-1].get_xaxis_transform())
        ax[-1].vlines(rad_low_t, ymin=0, ymax=1, linestyles='dashed',
                      color='coral',
                      transform=ax[-1].get_xaxis_transform())
        ax[-1].vlines(rad_up_t, ymin=0, ymax=1, linestyles='dashed',
                      color='coral',
                      transform=ax[-1].get_xaxis_transform())
        ax[-1].vlines(rad_start, ymin=0, ymax=1, color='coral',
                      transform=ax[-1].get_xaxis_transform())
        ax[-1].fill_between(cld_intervals, 0, 1, where=cld_highlight,
                            color='lightskyblue', alpha=0.5,
                            transform=ax[-1].get_xaxis_transform())
        ax[-1].vlines(cld_low_t, ymin=0, ymax=1, linestyles='dashed',
                      color='lightskyblue',
                      transform=ax[-1].get_xaxis_transform())
        ax[-1].vlines(cld_up_t, ymin=0, ymax=1, linestyles='dashed',
                      color='lightskyblue',
                      transform=ax[-1].get_xaxis_transform())
        ax[-1].vlines(cld_start, ymin=0, ymax=1, color='lightskyblue',
                      transform=ax[-1].get_xaxis_transform())
        ay[-1].fill_between(rad_intervals, 0, 1, where=rad_highlight,
                            color='coral', alpha=0.5,
                            transform=ay[-1].get_xaxis_transform())
        ay[-1].vlines(rad_low_t, ymin=0, ymax=1, linestyles='dashed',
                      color='coral',
                      transform=ay[-1].get_xaxis_transform())
        ay[-1].vlines(rad_up_t, ymin=0, ymax=1, linestyles='dashed',
                      color='coral',
                      transform=ay[-1].get_xaxis_transform())
        ay[-1].vlines(rad_start, ymin=0, ymax=1, color='coral',
                      transform=ay[-1].get_xaxis_transform())
        ay[-1].fill_between(cld_intervals, 0, 1, where=cld_highlight,
                            color='lightskyblue', alpha=0.5,
                            transform=ay[-1].get_xaxis_transform())
        ay[-1].vlines(cld_low_t, ymin=0, ymax=1, linestyles='dashed',
                      color='lightskyblue',
                      transform=ay[-1].get_xaxis_transform())
        ay[-1].vlines(cld_up_t, ymin=0, ymax=1, linestyles='dashed',
                      color='lightskyblue',
                      transform=ay[-1].get_xaxis_transform())
        ay[-1].vlines(cld_start, ymin=0, ymax=1, color='lightskyblue',
                      transform=ay[-1].get_xaxis_transform())

        if quantity == 'q_s':

            ax[-1].plot(time_fpg_wT, q_95_wT, color=colors[1])
            ax[-1].set_title('Safety factor')
            ax[-1].set_xlabel('s')

            ay[-1].plot(time_fpg_wP, q_95_wP, color=colors[1])
            ay[-1].set_title('Safety factor')
            ay[-1].set_xlabel('s')

        if quantity == 'f_exp':
            ax[-1].plot(time_fpg_wT, f_exp_wT, color=colors[1])
            ax[-1].set_title('Flux expansion')
            ax[-1].set_xlabel('s')

            ay[-1].plot(time_fpg_wP, f_exp_wP, color=colors[1])
            ay[-1].set_title('Flux expansion')
            ay[-1].set_xlabel('s')

        if quantity == 'n_0':
            ax[-1].plot(time_iob_wT, n_0_wT, color=colors[3])
            ax[-1].set_title('Neutral density (m^-3)')
            ax[-1].set_xlabel('s')

            ay[-1].plot(time_iob_wP, n_0_wP, color=colors[3])
            ay[-1].set_title('Neutral density (m^-3)')
            ay[-1].set_xlabel('s')

        if quantity == 'n_u':
            ax[-1].plot(time_ida_wT, n_u_wT, color=colors[4])
            ax[-1].set_title('Upstream density (m^-3)')
            ax[-1].set_xlabel('s')

            ay[-1].plot(time_ida_wP, n_u_wP, color=colors[4])
            ay[-1].set_title('Upstream density (m^-3)')
            ay[-1].set_xlabel('s')

        if quantity == 'T_u':
            ax[-1].plot(time_ida_wT, T_u_wT, color=colors[4])
            ax[-1].set_title('Upstream temperature (ev)')
            ax[-1].set_xlabel('s')

            ay[-1].plot(time_wP, P_tot_wP - P_rad_wP, color=colors[4])
            ay[-1].set_title('Power through the separatrix (W)')
            ay[-1].set_xlabel('s')

        if quantity == '2pm':
            ax[-1].plot(time_2pm_w2pm, T_u_w2pm, color=colors[4])
            ax[-1].set_title('Upstream temperature reconstructed (ev)')
            ax[-1].set_xlabel('s')

            ay[-1].fill_between(time_w2pm, X_A_lw2pm, X_A_uw2pm,
                                color=colors[0], alpha=0.5)
            ay[-1].plot(time_w2pm, X_A_w2pm, color=colors[0])
            ay[-1].set_title('Access parameter evolution with ' +
                             'reconstructed upstream parameters')
            ay[-1].set_xlabel('s')

        if quantity == 'z_XPR':
            ax[-1].plot(time_xpr, z_xpr, color=colors[2])
            ax[-1].set_title('XPR height (m)')
            ax[-1].set_xlabel('s')

            ay[-1].plot(time_xpr, z_xpr, color=colors[2])
            ay[-1].set_title('XPR height (m)')
            ay[-1].set_xlabel('s')

else:
    # Subplots
    ax1 = plt.subplot2grid((2, 1), (0, 0), rowspan=1, colspan=1)
    ay1 = plt.subplot2grid((2, 1), (1, 0), rowspan=1, colspan=1)

# Access parameter sublpot with T_u
ax1.fill_between(rad_intervals, 0, 1, where=rad_highlight, color='coral',
                 alpha=0.5, transform=ax1.get_xaxis_transform())
ax1.vlines(rad_low_t, ymin=0, ymax=1, linestyles='dashed', color='coral',
           transform=ax1.get_xaxis_transform())
ax1.vlines(rad_up_t, ymin=0, ymax=1, linestyles='dashed', color='coral',
           transform=ax1.get_xaxis_transform())
ax1.vlines(rad_start, ymin=0, ymax=1, color='coral',
           transform=ax1.get_xaxis_transform())
ax1.fill_between(cld_intervals, 0, 1, where=cld_highlight,
                 color='lightskyblue', alpha=0.5,
                 transform=ax1.get_xaxis_transform())
ax1.vlines(cld_low_t, ymin=0, ymax=1, linestyles='dashed',
           color='lightskyblue', transform=ax1.get_xaxis_transform())
ax1.vlines(cld_up_t, ymin=0, ymax=1, linestyles='dashed',
           color='lightskyblue', transform=ax1.get_xaxis_transform())
ax1.vlines(cld_start, ymin=0, ymax=1, color='lightskyblue',
           transform=ax1.get_xaxis_transform())
ax1.fill_between(time_wT, X_A_lwT, X_A_uwT, color=colors[1], alpha=0.2)
ax1.plot(time_wT, X_A_wT, color=colors[1])
ax1.set_title('Access parameter evolution with $T_u$')
ax1.set_xlabel('s')

# Access parameter sublpot with P_sep
ay1.fill_between(rad_intervals, 0, 1, where=rad_highlight, color='coral',
                 alpha=0.5, transform=ay1.get_xaxis_transform())
ay1.vlines(rad_low_t, ymin=0, ymax=1, linestyles='dashed', color='coral',
           transform=ay1.get_xaxis_transform())
ay1.vlines(rad_up_t, ymin=0, ymax=1, linestyles='dashed', color='coral',
           transform=ay1.get_xaxis_transform())
ay1.vlines(rad_start, ymin=0, ymax=1, color='coral',
           transform=ay1.get_xaxis_transform())
ay1.fill_between(cld_intervals, 0, 1, where=cld_highlight,
                 color='lightskyblue', alpha=0.5,
                 transform=ay1.get_xaxis_transform())
ay1.vlines(cld_low_t, ymin=0, ymax=1, linestyles='dashed',
           color='lightskyblue', transform=ay1.get_xaxis_transform())
ay1.vlines(cld_up_t, ymin=0, ymax=1, linestyles='dashed',
           color='lightskyblue', transform=ay1.get_xaxis_transform())
ay1.vlines(cld_start, ymin=0, ymax=1, color='lightskyblue',
           transform=ay1.get_xaxis_transform())
ay1.fill_between(time_wP, X_A_lwP, X_A_uwP, color=colors[1], alpha=0.2)
ay1.plot(time_wP, X_A_wP, color=colors[1])
ay1.set_title('Access parameter evolution with $P_sep$')
ay1.set_xlabel('s')

# Show plot or save
plt.tight_layout()
plt.show()
